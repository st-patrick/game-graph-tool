<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>RPG Story / Map Graph Tool</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b1120;
      --bg-alt: #020617;
      --panel: #020617;
      --panel-border: #111827;
      --node-bg: #111827;
      --node-border: #4b5563;
      --node-selected: #38bdf8;
      --node-text: #e5e7eb;
      --accent: #22c55e;
      --accent-soft: rgba(34, 197, 94, 0.15);
      --grid: rgba(148, 163, 184, 0.15);
      --edge: #6b7280;
      --edge-highlight: #38bdf8;
      --danger: #ef4444;
      --text-muted: #9ca3af;
      --toolbar-height: 52px;
      --status-height: 24px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        sans-serif;
      background: radial-gradient(circle at top, #111827 0, #020617 55%, #000 100%);
      color: #e5e7eb;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    #toolbar {
      height: var(--toolbar-height);
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.25rem 0.75rem;
      background: linear-gradient(to right, #020617, #020617);
      border-bottom: 1px solid var(--panel-border);
      font-size: 0.85rem;
      flex-wrap: wrap;
    }

    #toolbar label {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    input,
    select,
    button {
      font-family: inherit;
      font-size: 0.85rem;
    }

    #nodeTextInput {
      min-width: 180px;
      max-width: 260px;
      padding: 0.3rem 0.5rem;
      border-radius: 999px;
      border: 1px solid #1f2933;
      background: #020617;
      color: #f9fafb;
    }

    #nodeTextInput:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }

    select {
      padding: 0.25rem 1.5rem 0.25rem 0.5rem;
      border-radius: 999px;
      border: 1px solid #1f2933;
      background: #020617;
      color: #f9fafb;
    }

    button {
      border-radius: 999px;
      border: 1px solid #1f2933;
      background: #020617;
      color: #f9fafb;
      padding: 0.3rem 0.9rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      white-space: nowrap;
    }

    button:hover:not(:disabled) {
      border-color: #4b5563;
      background: #030712;
    }

    button:disabled {
      opacity: 0.4;
      cursor: default;
    }

    .btn-primary {
      border-color: var(--accent);
      background: radial-gradient(circle at top left, #16a34a 0, #052e16 60%);
    }

    .btn-primary:hover:not(:disabled) {
      background: radial-gradient(circle at top left, #22c55e 0, #052e16 60%);
    }

    .btn-danger {
      border-color: rgba(239, 68, 68, 0.45);
      background: radial-gradient(circle at top left, rgba(239, 68, 68, 0.1) 0, #020617 60%);
      color: #fecaca;
    }

    .btn-toggle.active {
      border-color: var(--node-selected);
      background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.2) 0, #020617 60%);
      color: #f0f9ff;
    }

    .spacer {
      flex: 1;
    }

    #canvasWrapper {
      position: relative;
      flex: 1;
      overflow: hidden;
      background: radial-gradient(circle at top, #020617 0, #020617 45%, #020617 100%);
      cursor: default;
    }

    #canvasGrid {
      position: absolute;
      inset: 0;
      background-image:
        linear-gradient(var(--grid) 1px, transparent 1px),
        linear-gradient(90deg, var(--grid) 1px, transparent 1px);
      background-size: 40px 40px;
      opacity: 0.55;
      pointer-events: none;
    }

    /* Huge world plane so we don't hit edges */
    #edgesSvg {
      position: absolute;
      left: 0;
      top: 0;
      width: 100000px;
      height: 100000px;
      pointer-events: none;
      overflow: visible;
    }

    #nodesLayer {
      position: absolute;
      left: 0;
      top: 0;
      width: 100000px;
      height: 100000px;
      pointer-events: none;
    }

    #nodesLayer,
    #edgesSvg {
      transform-origin: 0 0;
    }

    .node {
      position: absolute;
      min-width: 140px;
      max-width: 260px;
      padding: 0.35rem 0.55rem;
      border-radius: 0.75rem;
      background: radial-gradient(circle at top left, #020617 0, #020617 60%);
      border: 1px solid var(--node-border);
      color: var(--node-text);
      box-shadow:
        0 12px 30px rgba(0, 0, 0, 0.7),
        0 0 0 1px rgba(15, 23, 42, 0.8);
      cursor: grab;
      user-select: none;
      pointer-events: auto;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      transition: box-shadow 0.12s ease, border-color 0.12s ease,
                  transform 0.06s ease;
    }

    .node:active {
      cursor: grabbing;
      transform: scale(1.01);
    }

    .node.selected {
      border-color: var(--node-selected);
      box-shadow:
        0 0 0 1px rgba(56, 189, 248, 0.9),
        0 14px 35px rgba(15, 23, 42, 0.9);
    }

    .node.pending-from {
      border-style: dashed;
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }

    /* Playtime node styling */
    .node-type-playtime {
      background: radial-gradient(circle at top left, #1e293b 0, #020617 60%);
      border-color: #facc15;
    }

    .node-type-playtime .node-pill {
      border-color: #facc15;
      color: #facc15;
    }

    .node-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.25rem;
      margin-bottom: 0.2rem;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
    }

    .node-pill {
      padding: 0.05rem 0.4rem;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(51, 65, 85, 0.7);
      font-size: 0.68rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: #9ca3af;
      white-space: nowrap;
    }

    .node-id {
      font-variant-numeric: tabular-nums;
      opacity: 0.7;
    }

    .node-body {
      font-size: 0.8rem;
      line-height: 1.25;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .node-title {
      font-size: 0.85rem;
      font-weight: 500;
      margin-bottom: 0.15rem;
      color: #e5e7eb;
    }

    .node-fulltext {
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .edge-line {
      stroke: var(--edge);
      stroke-width: 2;
      stroke-linecap: round;
    }

    .edge-line.highlight {
      stroke: var(--edge-highlight);
      stroke-width: 2.4;
    }

    #statusBar {
      height: var(--status-height);
      font-size: 0.7rem;
      display: flex;
      align-items: center;
      padding: 0 0.75rem;
      border-top: 1px solid var(--panel-border);
      background: radial-gradient(circle at top, #020617 0, #020617 40%, #020617 100%);
      color: var(--text-muted);
      gap: 1.5rem;
    }

    #statusBar span {
      opacity: 0.85;
    }

    #statusBar strong {
      font-weight: 500;
      color: #e5e7eb;
    }

    #canvasWrapper.connect-mode {
      cursor: crosshair;
    }

    #canvasWrapper.connect-mode .node {
      cursor: crosshair;
    }

    #resetZoomBtn {
      margin-left: auto;
      font-size: 0.7rem;
      padding: 0.1rem 0.5rem;
      line-height: 1;
    }

    #modalOverlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.76);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 40;
    }

    #modalOverlay.visible {
      display: flex;
    }

    #modal {
      background: #020617;
      border-radius: 0.75rem;
      border: 1px solid #1f2937;
      max-width: 640px;
      width: min(640px, 100% - 2rem);
      box-shadow: 0 24px 80px rgba(0, 0, 0, 0.9);
      padding: 1rem 1rem 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      font-size: 0.85rem;
    }

    #modalHeader h2 {
      margin: 0;
      font-size: 0.95rem;
      font-weight: 600;
    }

    #modalDescription {
      margin: 0;
      color: var(--text-muted);
      font-size: 0.8rem;
    }

    #modalTextarea {
      width: 100%;
      min-height: 220px;
      resize: vertical;
      border-radius: 0.5rem;
      border: 1px solid #1f2937;
      background: #020617;
      color: #e5e7eb;
      padding: 0.5rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 0.75rem;
    }

    #modalButtons {
      margin-top: 0.5rem;
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      padding-top: 0.25rem;
      border-top: 1px solid #111827;
    }

    /* Selection rectangle */
    #selectionRect {
      position: absolute;
      border: 1px dashed #38bdf8;
      background: rgba(56, 189, 248, 0.15);
      pointer-events: none;
      display: none;
    }

    @media (max-width: 768px) {
      #toolbar {
        height: auto;
      }
      #nodeTextInput {
        flex: 1;
        min-width: 0;
      }
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <label for="viewSelect">View</label>
    <select id="viewSelect"></select>
    <button id="addViewBtn" title="Create a new layout/view based on the current positions">
      + View
    </button>

    <span style="width:1px;height:20px;background:#111827;margin:0 0.5rem;"></span>

    <input id="nodeTextInput" type="text" placeholder="New event title / label" />
    <button id="addNodeBtn" class="btn-primary" title="Add a new event node">
      + Event
    </button>
    <button id="addPlaytimeBtn" title="Add a playtime marker node">
      ⏱ Playtime
    </button>

    <button id="connectModeBtn" class="btn-toggle" title="Connect nodes: click source, then target">
      ⇢ Connect
    </button>

    <button id="deleteNodeBtn" class="btn-danger" disabled title="Delete selected node(s)">
      ⌫ Delete
    </button>

    <div class="spacer"></div>

    <span id="hintText" style="font-size:0.75rem;color:var(--text-muted);">
      Drag nodes, left-drag empty space to lasso, Ctrl/Cmd+wheel to zoom, C = connect, + = new, Del = delete.
    </span>
  </div>

  <div id="canvasWrapper">
    <div id="canvasGrid"></div>
    <svg id="edgesSvg"></svg>
    <div id="nodesLayer"></div>
    <div id="selectionRect"></div>
  </div>

  <div id="statusBar">
    <span id="statusView"></span>
    <span id="statusCounts"></span>
    <span id="statusMode"></span>
    <button id="resetZoomBtn" title="Reset zoom and pan to 100%">100%</button>
  </div>

  <div id="modalOverlay">
    <div id="modal">
      <div id="modalHeader">
        <h2 id="modalTitle"></h2>
      </div>
      <p id="modalDescription"></p>
      <textarea id="modalTextarea" spellcheck="false"></textarea>
      <div id="modalButtons">
        <button id="modalPrimaryBtn" class="btn-primary"></button>
        <button id="modalSecondaryBtn">Close</button>
      </div>
    </div>
  </div>

  <script>
    (function () {
      const STORAGE_KEY = "rpg_graph_tool_v1";
      const GRID_WORLD_SIZE = 80;

      function createDefaultState() {
        const base = {
          nodes: [],
          edges: [],
          views: [
            { id: "story", name: "Story" },
            { id: "map", name: "Map" }
          ],
          currentViewId: "story",
          nextNodeId: 1,
          viewTransforms: {}
        };
        base.views.forEach(v => {
          base.viewTransforms[v.id] = { scale: 1, offsetX: 0, offsetY: 0 };
        });
        return base;
      }

      function loadState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return createDefaultState();
          const parsed = JSON.parse(raw);
          const defaults = createDefaultState();
          const s = Object.assign({}, defaults, parsed);

          if (!Array.isArray(s.nodes)) s.nodes = [];
          if (!Array.isArray(s.edges)) s.edges = [];
          if (!Array.isArray(s.views) || s.views.length === 0) {
            s.views = defaults.views;
          }
          if (!s.currentViewId) s.currentViewId = s.views[0].id;

          if (!s.nextNodeId) {
            const maxId = s.nodes.reduce(
              (max, n) => typeof n.id === "number" && n.id > max ? n.id : max,
              0
            );
            s.nextNodeId = maxId + 1;
          }

          if (!s.viewTransforms || typeof s.viewTransforms !== "object") {
            s.viewTransforms = {};
          }
          s.views.forEach(v => {
            if (!s.viewTransforms[v.id]) {
              s.viewTransforms[v.id] = { scale: 1, offsetX: 0, offsetY: 0 };
            }
          });

          s.nodes.forEach(n => {
            if (!n.positions || typeof n.positions !== "object") n.positions = {};
            if (!n.type) n.type = "event";
            if (typeof n.title !== "string") n.title = "";
            if (typeof n.fulltext !== "string") n.fulltext = "";
            if (!n.title && !n.fulltext && typeof n.text === "string" && n.text) {
              if (n.text.length > 80 || n.text.indexOf("\n") !== -1) {
                n.fulltext = n.text;
                n.title =
                  n.text.slice(0, 60).replace(/\s+$/, "") +
                  (n.text.length > 60 ? "…" : "");
              } else {
                n.title = n.text;
              }
            }
          });

          return s;
        } catch (e) {
          console.error("Failed to load state, resetting:", e);
          return createDefaultState();
        }
      }

      function saveState() {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        } catch (e) {
          console.error("Failed to save state:", e);
        }
      }

      let state = loadState();
      let selectedNodeId = null;
      let selectedNodeIds = new Set();
      let pendingFromId = null;
      let connectMode = false;
      let isDragging = false;
      let dragInfo = null;
      let isPanning = false;
      let panInfo = null;
      let isSelecting = false;
      let selectionInfo = null;
      let suppressNextCanvasClick = false;
      let nodeElementsById = new Map();

      const viewSelect = document.getElementById("viewSelect");
      const addViewBtn = document.getElementById("addViewBtn");
      const nodeTextInput = document.getElementById("nodeTextInput");
      const addNodeBtn = document.getElementById("addNodeBtn");
      const addPlaytimeBtn = document.getElementById("addPlaytimeBtn");
      const connectModeBtn = document.getElementById("connectModeBtn");
      const deleteNodeBtn = document.getElementById("deleteNodeBtn");
      const canvasWrapper = document.getElementById("canvasWrapper");
      const nodesLayer = document.getElementById("nodesLayer");
      const edgesSvg = document.getElementById("edgesSvg");
      const canvasGrid = document.getElementById("canvasGrid");
      const selectionRect = document.getElementById("selectionRect");
      const statusView = document.getElementById("statusView");
      const statusCounts = document.getElementById("statusCounts");
      const statusMode = document.getElementById("statusMode");
      const resetZoomBtn = document.getElementById("resetZoomBtn");

      const modalOverlay = document.getElementById("modalOverlay");
      const modalTitle = document.getElementById("modalTitle");
      const modalDescription = document.getElementById("modalDescription");
      const modalTextarea = document.getElementById("modalTextarea");
      const modalPrimaryBtn = document.getElementById("modalPrimaryBtn");
      const modalSecondaryBtn = document.getElementById("modalSecondaryBtn");
      let modalMode = null;

      function getViewById(id) {
        return state.views.find(v => v.id === id) || null;
      }

      function getNodeById(id) {
        return state.nodes.find(n => n.id === id) || null;
      }

      function getViewTransform(viewIdOpt) {
        const viewId = viewIdOpt || state.currentViewId;
        if (!state.viewTransforms || typeof state.viewTransforms !== "object") {
          state.viewTransforms = {};
        }
        let vt = state.viewTransforms[viewId];
        if (!vt) {
          vt = { scale: 1, offsetX: 0, offsetY: 0 };
          state.viewTransforms[viewId] = vt;
        }
        return vt;
      }

      function screenToWorld(x, y, viewIdOpt) {
        const vt = getViewTransform(viewIdOpt);
        return {
          x: (x - vt.offsetX) / vt.scale,
          y: (y - vt.offsetY) / vt.scale
        };
      }

      function applyViewTransform() {
        const vt = getViewTransform();
        const t = `translate(${vt.offsetX}px, ${vt.offsetY}px) scale(${vt.scale})`;
        nodesLayer.style.transform = t;
        edgesSvg.style.transform = t;
        updateGrid();
      }

      function updateGrid() {
        const vt = getViewTransform();
        let size = GRID_WORLD_SIZE * vt.scale;
        if (size < 2) size = 2;
        canvasGrid.style.backgroundSize = `${size}px ${size}px`;

        const offsetX = ((vt.offsetX % size) + size) % size;
        const offsetY = ((vt.offsetY % size) + size) % size;
        canvasGrid.style.backgroundPosition = `${offsetX}px ${offsetY}px`;
      }

      function ensurePositionsForCurrentView() {
        const viewId = state.currentViewId;
        state.nodes.forEach((node, index) => {
          if (!node.positions) node.positions = {};
          if (!node.positions[viewId]) {
            let fallbackPos = null;
            const viewIds = Object.keys(node.positions);
            if (viewIds.length > 0) fallbackPos = node.positions[viewIds[0]];
            if (fallbackPos) {
              node.positions[viewId] = {
                x: fallbackPos.x + 20,
                y: fallbackPos.y + 20
              };
            } else {
              node.positions[viewId] = {
                x: 80 + index * 150,
                y: 80
              };
            }
          }
        });
      }

      function cloneLayoutToNewView(fromViewId, toViewId) {
        state.nodes.forEach((node, index) => {
          if (!node.positions) node.positions = {};
          const fromPos = node.positions[fromViewId];
          if (fromPos) {
            node.positions[toViewId] = { x: fromPos.x, y: fromPos.y };
          } else {
            node.positions[toViewId] = {
              x: 80 + index * 150,
              y: 80
            };
          }
        });
      }

      function clearSelection() {
        selectedNodeIds.clear();
        selectedNodeId = null;
        pendingFromId = null;
      }

      function setSingleSelection(id) {
        selectedNodeIds.clear();
        if (id != null) {
          selectedNodeIds.add(id);
          selectedNodeId = id;
        } else {
          selectedNodeId = null;
        }
      }

      function rebuildViewOptions() {
        viewSelect.innerHTML = "";
        state.views.forEach(view => {
          const opt = document.createElement("option");
          opt.value = view.id;
          opt.textContent = view.name;
          viewSelect.appendChild(opt);
        });
        if (!getViewById(state.currentViewId)) {
          state.currentViewId = state.views[0].id;
        }
        viewSelect.value = state.currentViewId;
      }

      function setConnectMode(on) {
        connectMode = !!on;
        pendingFromId = null;
        if (connectMode) {
          connectModeBtn.classList.add("active");
          canvasWrapper.classList.add("connect-mode");
        } else {
          connectModeBtn.classList.remove("active");
          canvasWrapper.classList.remove("connect-mode");
        }
        updateStatusBar();
        render();
      }

      function updateStatusBar() {
        const view = getViewById(state.currentViewId);
        const vt = getViewTransform();
        statusView.innerHTML = `View: <strong>${view ? view.name : "Unknown"}</strong>`;
        statusCounts.textContent =
          `Nodes: ${state.nodes.length} | Edges: ${state.edges.length} | Zoom: ${Math.round(vt.scale * 100)}%`;
        const modeText = connectMode ? "Connect mode" : "Navigate / drag mode";
        const selCount = selectedNodeIds.size;
        let selInfo = "";
        if (selCount === 1 && selectedNodeId != null) {
          selInfo = ` | 1 node selected (#${selectedNodeId})`;
        } else if (selCount > 1) {
          selInfo = ` | ${selCount} nodes selected`;
        }
        statusMode.textContent = `Mode: ${modeText}${selInfo}`;
        deleteNodeBtn.disabled = selCount === 0;
      }

      function createEdge(fromId, toId) {
        if (!fromId || !toId || fromId === toId) return;
        const exists = state.edges.some(e => e.from === fromId && e.to === toId);
        if (exists) return;
        const edgeId = `e_${fromId}_${toId}_${Math.random().toString(36).slice(2, 7)}`;
        state.edges.push({ id: edgeId, from: fromId, to: toId, type: "sequence" });
      }

      function deleteSelectedNodes() {
        if (selectedNodeIds.size === 0) return;
        const idsToDelete = new Set(selectedNodeIds);
        state.nodes = state.nodes.filter(n => !idsToDelete.has(n.id));
        state.edges = state.edges.filter(e => !idsToDelete.has(e.from) && !idsToDelete.has(e.to));
        clearSelection();
        saveState();
        render();
      }

      function clearSvg() {
        while (edgesSvg.firstChild) edgesSvg.removeChild(edgesSvg.firstChild);
      }

      function updateEdges() {
        clearSvg();
        if (state.edges.length === 0) return;

        const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
        marker.setAttribute("id", "arrowhead");
        marker.setAttribute("markerWidth", "8");
        marker.setAttribute("markerHeight", "6");
        marker.setAttribute("refX", "8");
        marker.setAttribute("refY", "3");
        marker.setAttribute("orient", "auto");
        marker.setAttribute("markerUnits", "strokeWidth");

        const markerPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
        markerPath.setAttribute("d", "M0,0 L8,3 L0,6 z");
        markerPath.setAttribute("fill", "currentColor");

        marker.appendChild(markerPath);
        defs.appendChild(marker);
        edgesSvg.appendChild(defs);

        state.edges.forEach(edge => {
          const fromEl = nodeElementsById.get(edge.from);
          const toEl = nodeElementsById.get(edge.to);
          if (!fromEl || !toEl) return;

          const x1 = fromEl.offsetLeft + fromEl.offsetWidth / 2;
          const y1 = fromEl.offsetTop + fromEl.offsetHeight / 2;
          const x2 = toEl.offsetLeft + toEl.offsetWidth / 2;
          const y2 = toEl.offsetTop + toEl.offsetHeight / 2;

          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          line.setAttribute("x1", String(x1));
          line.setAttribute("y1", String(y1));
          line.setAttribute("x2", String(x2));
          line.setAttribute("y2", String(y2));
          line.setAttribute("class", "edge-line");

          if (selectedNodeIds.size > 0 &&
              (selectedNodeIds.has(edge.from) || selectedNodeIds.has(edge.to))) {
            line.classList.add("highlight");
          }

          edgesSvg.appendChild(line);
        });
      }

      function positionNodeElement(node) {
        const pos = node.positions[state.currentViewId];
        if (!pos) return;
        const el = nodeElementsById.get(node.id);
        if (!el) return;
        el.style.left = pos.x + "px";
        el.style.top = pos.y + "px";
      }

      function attachNodeEvents(nodeElement, node) {
        nodeElement.addEventListener("mousedown", e => {
          if (e.button !== 0) return;
          e.preventDefault();
          e.stopPropagation();

          // Determine which nodes to drag
          let dragIds;
          if (selectedNodeIds.has(node.id) && selectedNodeIds.size > 0) {
            dragIds = Array.from(selectedNodeIds);
          } else {
            // Start a new single selection on this node
            selectedNodeIds.clear();
            selectedNodeIds.add(node.id);
            selectedNodeId = node.id;
            // Manually update highlight without full re-render
            nodeElementsById.forEach(el => el.classList.remove("selected"));
            nodeElement.classList.add("selected");
            dragIds = [node.id];
          }

          isDragging = true;
          const pos = node.positions[state.currentViewId];
          dragInfo = {
            draggedIds: dragIds,
            startClientX: e.clientX,
            startClientY: e.clientY,
            startPositions: {}
          };

          dragIds.forEach(id => {
            const n = getNodeById(id);
            if (!n) return;
            let p = n.positions[state.currentViewId];
            if (!p) {
              p = { x: 0, y: 0 };
              n.positions[state.currentViewId] = p;
            }
            dragInfo.startPositions[id] = { x: p.x, y: p.y };
          });

          document.addEventListener("mousemove", onMouseMove);
          document.addEventListener("mouseup", onMouseUp);
          updateStatusBar();
        });

        nodeElement.addEventListener("click", e => {
          e.stopPropagation();
          handleNodePrimaryClick(node);
        });

        nodeElement.addEventListener("dblclick", e => {
          e.stopPropagation();
          const newTitle = window.prompt("Edit node title:", node.title || "");
          if (newTitle === null) return;
          const newFull = window.prompt("Edit node full text:", node.fulltext || "");
          if (newFull === null) return;
          node.title = newTitle;
          node.fulltext = newFull;
          saveState();
          render();
        });

        nodeElement.addEventListener("contextmenu", e => {
          e.preventDefault();
          e.stopPropagation();
          // Context menu applies to this node only
          setSingleSelection(node.id);
          if (window.confirm("Delete node #" + node.id + " and its edges?")) {
            deleteSelectedNodes();
          } else {
            render();
          }
        });
      }

      function onMouseMove(e) {
        if (!isDragging || !dragInfo) return;
        e.preventDefault();
        const vt = getViewTransform();
        const dxScreen = e.clientX - dragInfo.startClientX;
        const dyScreen = e.clientY - dragInfo.startClientY;
        const dxWorld = dxScreen / vt.scale;
        const dyWorld = dyScreen / vt.scale;

        dragInfo.draggedIds.forEach(id => {
          const node = getNodeById(id);
          if (!node) return;
          let pos = node.positions[state.currentViewId];
          if (!pos) {
            pos = { x: 0, y: 0 };
            node.positions[state.currentViewId] = pos;
          }
          const startPos = dragInfo.startPositions[id] || { x: pos.x, y: pos.y };
          pos.x = startPos.x + dxWorld;
          pos.y = startPos.y + dyWorld;
          positionNodeElement(node);
        });

        updateEdges();
      }

      function onMouseUp(e) {
        if (!isDragging) return;
        isDragging = false;
        dragInfo = null;
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
        saveState();
      }

      function handleNodePrimaryClick(node) {
        if (connectMode) {
          if (!pendingFromId) {
            pendingFromId = node.id;
            setSingleSelection(node.id);
          } else {
            if (pendingFromId !== node.id) {
              // Toggle edge: if exists, delete; else create
              const existingIndex = state.edges.findIndex(
                e => e.from === pendingFromId && e.to === node.id
              );
              if (existingIndex >= 0) {
                state.edges.splice(existingIndex, 1);
              } else {
                createEdge(pendingFromId, node.id);
              }
              saveState();
            }
            setSingleSelection(node.id);
            pendingFromId = null;
          }
        } else {
          setSingleSelection(node.id);
        }
        render();
      }

      function openImportModal() {
        modalMode = "import";
        modalTitle.textContent = "Import data";
        modalDescription.textContent =
          "Paste previously exported JSON and click Import. This will overwrite current data.";
        modalPrimaryBtn.textContent = "Import";
        modalTextarea.value = "";
        modalOverlay.classList.add("visible");
        setTimeout(() => modalTextarea.focus(), 0);
      }

      function closeModal() {
        modalOverlay.classList.remove("visible");
        modalMode = null;
        modalTextarea.value = "";
      }

      modalSecondaryBtn.addEventListener("click", closeModal);
      modalOverlay.addEventListener("click", e => {
        if (e.target === modalOverlay) closeModal();
      });

      modalPrimaryBtn.addEventListener("click", () => {
        if (modalMode !== "import") return;
        const text = modalTextarea.value.trim();
        if (!text) {
          alert("Paste some JSON first.");
          return;
        }
        try {
          JSON.parse(text);
        } catch (e) {
          alert("Invalid JSON: " + e.message);
          return;
        }
        try {
          localStorage.setItem(STORAGE_KEY, text);
          state = loadState();
          clearSelection();
          nodeElementsById.clear();
          rebuildViewOptions();
          ensurePositionsForCurrentView();
          saveState();
          render();
          closeModal();
        } catch (e) {
          alert("Import failed: " + e.message);
        }
      });

      function downloadJson() {
        const data = JSON.stringify(state, null, 2);
        const blob = new Blob([data], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        const date = new Date().toISOString().slice(0, 10);
        a.href = url;
        a.download = "rpg_graph_" + date + ".json";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      // Selection rectangle helpers
      function updateSelectionRect() {
        if (!selectionInfo) return;
        const x1 = selectionInfo.startX;
        const y1 = selectionInfo.startY;
        const x2 = selectionInfo.currentX;
        const y2 = selectionInfo.currentY;
        const left = Math.min(x1, x2);
        const top = Math.min(y1, y2);
        const width = Math.abs(x2 - x1);
        const height = Math.abs(y2 - y1);
        selectionRect.style.left = left + "px";
        selectionRect.style.top = top + "px";
        selectionRect.style.width = width + "px";
        selectionRect.style.height = height + "px";
      }

      function applySelectionFromRect() {
        if (!selectionInfo) return;
        const x1 = selectionInfo.startX;
        const y1 = selectionInfo.startY;
        const x2 = selectionInfo.currentX;
        const y2 = selectionInfo.currentY;
        const sx1 = Math.min(x1, x2);
        const sy1 = Math.min(y1, y2);
        const sx2 = Math.max(x1, x2);
        const sy2 = Math.max(y1, y2);

        const wrapRect = canvasWrapper.getBoundingClientRect();

        selectedNodeIds.clear();
        selectedNodeId = null;
        pendingFromId = null;

        nodeElementsById.forEach((el, id) => {
          const r = el.getBoundingClientRect();
          const nx1 = r.left - wrapRect.left;
          const ny1 = r.top - wrapRect.top;
          const nx2 = r.right - wrapRect.left;
          const ny2 = r.bottom - wrapRect.top;

          const intersects =
            nx2 >= sx1 && nx1 <= sx2 &&
            ny2 >= sy1 && ny1 <= sy2;

          if (intersects) {
            selectedNodeIds.add(id);
            selectedNodeId = id;
          }
        });

        render();
      }

      function onSelectionMouseMove(e) {
        if (!isSelecting || !selectionInfo) return;
        e.preventDefault();
        const wrapRect = canvasWrapper.getBoundingClientRect();
        selectionInfo.currentX = e.clientX - wrapRect.left;
        selectionInfo.currentY = e.clientY - wrapRect.top;
        updateSelectionRect();
      }

      function onSelectionMouseUp(e) {
        if (!isSelecting) return;
        isSelecting = false;
        document.removeEventListener("mousemove", onSelectionMouseMove);
        document.removeEventListener("mouseup", onSelectionMouseUp);
        selectionRect.style.display = "none";
        applySelectionFromRect();
        selectionInfo = null;
        // prevent the click after mouseup from nuking the new selection
        suppressNextCanvasClick = true;
      }

      // Global hotkeys
      window.addEventListener("keydown", e => {
        const tag = (e.target && e.target.tagName) || "";
        const isTypingTarget =
          tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT";

        // Modal has priority
        if (modalOverlay.classList.contains("visible")) {
          if (e.key === "Escape") {
            e.preventDefault();
            closeModal();
          }
          return;
        }

        // Export / import (Ctrl/Cmd + Shift + E/I)
        if ((e.ctrlKey || e.metaKey) && e.shiftKey) {
          if (isTypingTarget) return;
          if (e.code === "KeyE") {
            e.preventDefault();
            downloadJson();
          } else if (e.code === "KeyI") {
            e.preventDefault();
            openImportModal();
          }
          return;
        }

        // Simple hotkeys (no modifiers, not typing)
        if (!isTypingTarget && !e.ctrlKey && !e.metaKey && !e.altKey) {
          if (e.key === "c" || e.key === "C") {
            e.preventDefault();
            setConnectMode(!connectMode);
          } else if (e.key === "+") {
            e.preventDefault();
            addNodeBtn.click();
          } else if (e.key === "Delete" || e.key === "Backspace") {
            if (selectedNodeIds.size > 0) {
              e.preventDefault();
              deleteNodeBtn.click();
            }
          } else if (e.key === "Escape") {
            e.preventDefault();
            if (connectMode) {
              setConnectMode(false);
            } else if (selectedNodeIds.size > 0) {
              clearSelection();
              render();
            }
          }
        }
      });

      viewSelect.addEventListener("change", () => {
        state.currentViewId = viewSelect.value;
        saveState();
        clearSelection();
        ensurePositionsForCurrentView();
        render();
      });

      addViewBtn.addEventListener("click", () => {
        const name = window.prompt("Name for new view/layout:", "");
        if (!name) return;
        const id =
          "v_" + name.toLowerCase().replace(/[^a-z0-9]+/g, "_") + "_" +
          Math.random().toString(36).slice(2, 6);

        const currentViewId = state.currentViewId;
        state.views.push({ id, name });
        cloneLayoutToNewView(currentViewId, id);

        const vt = getViewTransform(currentViewId);
        state.viewTransforms[id] = {
          scale: vt.scale,
          offsetX: vt.offsetX,
          offsetY: vt.offsetY
        };

        state.currentViewId = id;
        saveState();
        rebuildViewOptions();
        clearSelection();
        render();
      });

      function createNode(type) {
        let title = nodeTextInput.value;
        if (!title || !title.trim()) {
          title = (type === "playtime" ? "Playtime " : "Event ") + state.nextNodeId;
        }

        const node = {
          id: state.nextNodeId++,
          type: type,
          title: title,
          fulltext: "",
          positions: {}
        };

        state.views.forEach((view, index) => {
          const count = state.nodes.length;
          node.positions[view.id] = {
            x: 80 + count * 160,
            y: 80 + index * 120
          };
        });

        state.nodes.push(node);
        setSingleSelection(node.id);
        saveState();
        nodeTextInput.value = "";
        render();
        nodeTextInput.focus();
      }

      addNodeBtn.addEventListener("click", () => {
        createNode("event");
      });

      addPlaytimeBtn.addEventListener("click", () => {
        createNode("playtime");
      });

      nodeTextInput.addEventListener("keydown", e => {
        if (e.key === "Enter") {
          e.preventDefault();
          addNodeBtn.click();
        }
      });

      connectModeBtn.addEventListener("click", () => {
        setConnectMode(!connectMode);
      });

      deleteNodeBtn.addEventListener("click", () => {
        if (selectedNodeIds.size === 0) return;
        const plural = selectedNodeIds.size > 1;
        if (window.confirm(
          `Delete ${plural ? "selected nodes" : "selected node"} and all its edges?`
        )) {
          deleteSelectedNodes();
        }
      });

      canvasWrapper.addEventListener("click", e => {
        if (suppressNextCanvasClick) {
          suppressNextCanvasClick = false;
          return;
        }
        if (e.target.closest(".node")) return;
        clearSelection();
        render();
      });

      // Panning (middle mouse drag)
      function onPanMouseMove(e) {
        if (!isPanning || !panInfo) return;
        e.preventDefault();
        const vt = getViewTransform();
        vt.offsetX = panInfo.startOffsetX + (e.clientX - panInfo.startClientX);
        vt.offsetY = panInfo.startOffsetY + (e.clientY - panInfo.startClientY);
        applyViewTransform();
      }

      function onPanMouseUp(e) {
        if (!isPanning) return;
        isPanning = false;
        panInfo = null;
        document.removeEventListener("mousemove", onPanMouseMove);
        document.removeEventListener("mouseup", onPanMouseUp);
        saveState();
        updateStatusBar();
      }

      canvasWrapper.addEventListener("mousedown", e => {
        if (e.target.closest(".node")) return;

        // Middle mouse: pan
        if (e.button === 1) {
          e.preventDefault();
          isPanning = true;
          const vt = getViewTransform();
          panInfo = {
            startClientX: e.clientX,
            startClientY: e.clientY,
            startOffsetX: vt.offsetX,
            startOffsetY: vt.offsetY
          };
          document.addEventListener("mousemove", onPanMouseMove);
          document.addEventListener("mouseup", onPanMouseUp);
          return;
        }

        // Left mouse: selection rectangle
        if (e.button === 0) {
          e.preventDefault();
          const wrapRect = canvasWrapper.getBoundingClientRect();
          const startX = e.clientX - wrapRect.left;
          const startY = e.clientY - wrapRect.top;
          isSelecting = true;
          selectionInfo = {
            startX,
            startY,
            currentX: startX,
            currentY: startY
          };
          selectionRect.style.display = "block";
          updateSelectionRect();
          document.addEventListener("mousemove", onSelectionMouseMove);
          document.addEventListener("mouseup", onSelectionMouseUp);
        }
      });

      // Wheel: pan by default, zoom with Ctrl/Cmd
      canvasWrapper.addEventListener("wheel", e => {
        e.preventDefault();
        const vt = getViewTransform();

        if (e.ctrlKey || e.metaKey) {
          const rect = canvasWrapper.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          const worldBefore = screenToWorld(mouseX, mouseY);

          const delta = e.deltaY;
          const zoomFactor = delta < 0 ? 1.02 : 0.98; // ~2% per tick
          let newScale = vt.scale * zoomFactor;
          const minScale = 0.1;
          const maxScale = 2.0;
          if (newScale < minScale) newScale = minScale;
          if (newScale > maxScale) newScale = maxScale;

          vt.scale = newScale;
          vt.offsetX = mouseX - worldBefore.x * newScale;
          vt.offsetY = mouseY - worldBefore.y * newScale;

          applyViewTransform();
          saveState();
          updateStatusBar();
        } else {
          vt.offsetX -= e.deltaX;
          vt.offsetY -= e.deltaY;
          applyViewTransform();
          saveState();
          updateStatusBar();
        }
      }, { passive: false });

      resetZoomBtn.addEventListener("click", () => {
        const vt = getViewTransform();
        vt.scale = 1;
        vt.offsetX = 0;
        vt.offsetY = 0;
        applyViewTransform();
        saveState();
        updateStatusBar();
      });

      window.addEventListener("resize", () => {
        window.requestAnimationFrame(() => {
          updateEdges();
          updateGrid();
        });
      });

      rebuildViewOptions();
      ensurePositionsForCurrentView();
      saveState();
      render();

      function render() {
        nodeElementsById.clear();
        nodesLayer.innerHTML = "";

        ensurePositionsForCurrentView();

        state.nodes.forEach((node, index) => {
          let pos = node.positions[state.currentViewId];
          if (!pos) {
            pos = { x: 80 + index * 150, y: 80 };
            node.positions[state.currentViewId] = pos;
          }

          const nodeEl = document.createElement("div");
          nodeEl.className = "node";
          nodeEl.classList.add("node-type-" + (node.type || "event"));
          if (selectedNodeIds.has(node.id)) nodeEl.classList.add("selected");
          if (node.id === pendingFromId) nodeEl.classList.add("pending-from");

          const header = document.createElement("div");
          header.className = "node-header";

          const pill = document.createElement("div");
          pill.className = "node-pill";
          pill.textContent = (node.type || "event").toUpperCase();

          const idSpan = document.createElement("span");
          idSpan.className = "node-id";
          idSpan.textContent = "#" + node.id;

          header.appendChild(pill);
          header.appendChild(idSpan);

          const body = document.createElement("div");
          body.className = "node-body";

          const titleText = (node.title && node.title.trim()) ? node.title : "(untitled)";
          const fullText = node.fulltext || "";

          const titleEl = document.createElement("div");
          titleEl.className = "node-title";
          titleEl.textContent = titleText;

          const fullEl = document.createElement("div");
          fullEl.className = "node-fulltext";
          const snippet = fullText.length > 150
            ? fullText.slice(0, 147) + "…"
            : fullText;
          fullEl.textContent = snippet;

          body.appendChild(titleEl);
          if (snippet) body.appendChild(fullEl);

          nodeEl.appendChild(header);
          nodeEl.appendChild(body);

          nodeEl.title = titleText + (fullText ? "\n\n" + fullText : "");

          nodesLayer.appendChild(nodeEl);

          nodeElementsById.set(node.id, nodeEl);
          attachNodeEvents(nodeEl, node);
          positionNodeElement(node);
        });

        applyViewTransform();
        window.requestAnimationFrame(updateEdges);
        updateStatusBar();
      }
    })();
  </script>
</body>
</html>
